### 													数据结构与算法

#### 一、常见算法题

**tip1**：关于`while`循环中的` ~scanf()`,

可以经常在ACM代码中看到 `while(~scanf("%d",&n)){ } `，意思是在读到输入结尾时循环也结束。

一般在读到输入流结尾时，`scanf`返回的是`EOF`。

`EOF`是在头文件`stdio.h`中定义的常量，一般为`-1`。

`~EOF`则是对`EOF`进行按位取反操作，则为`00000000`。所以while条件不满足，循环结束。
		`while(~scanf())`  <==> ` while(scanf()!=EOF)`



**tip2:**   负数的二进制（负数是符号位为1）  

假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为：
		00000000 00000000 00000000 00000101

5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。
		

**-5 在计算机中如何表示？**

在计算机中，**负数以其正值的补码形式表达**。
	    什么叫补码呢？这得从原码，反码说起。

原码：一个整数，按照**绝对值大小**转换成的二进制数，称为原码。
		比如 00000000 00000000 00000000 00000101 是 5的 原码。

反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。
		取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）

00000000 00000000 00000000 00000101

11111111 11111111 11111111 11111010 

补码：反码加1称为补码。

也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码

11111111 11111111 11111111 11111010 + 1 =

11111111 11111111 11111111 11111011

**tip3：**  位运算、左移、右移

+ 按位与 & 

  **相同位的数字都为1则为1**

  ```java
  5 二进制 101
  3 二进制 011
      结果 001
  ```

+ 按位或 |

  **相同位的数字有一个为1，则为1**

  ```java
  5 二进制 101
  3 二进制 011
      结果 111
  ```

+ 按位异或

  **相同位的数字不相同则为 1**

  ```java
  5 二进制 101
  3 二进制 011
      结果 110
  ```

  **按位异或应用场景**

  判断两个字符串是否相同？利用`按位异或`相同位数的数字一样则为0的属性来进行对比

+ 左移 <<

  将运算数的二进制整体左移`指定位数`，低位用0补齐，将一个数`左移一位扩大2倍`，以此类推

  ```python
  0 0 0 0 0 0 0 1            1
  整体左移一位，低位补0
  0 0 0 0 0 0 1 0            2
  再次左移一位
  0 0 0 0 0 1 0 0            4
  ```

+ 右移 >>

  将运算数的二进制整体右移`指定位数`，高位用0补齐，将一个数`右移一位缩小2倍`，以此类推

  ```py
  0 0 0 0 0 1 0 0            4
  整体右移一位，高位补0
  0 0 0 0 0 0 1 0            2
  再次右移一位
  0 0 0 0 0 0 0 1            1
  ```

  demo：请定义一个宏，比较两个数a、b的大小，不能使用大于、小于、if语句。
  一看到这种不能用乘除、if等常规方法。那我们就要想到位运算；

  右移的情况比较复杂，

  假如是无符号数，那么右移，左边空出的位补0；
  假如是有符号负数，那么右移，左边空出的会补1；
  所以建议使用左移；

##### 1.1 位运算

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

**常识1：在计算机系统中，数值一律用补码来表示和存储**

**常识2：正数的原码、反码、补码都是其本身。**

```java

//超级简单容易理解 &(与)
//把这个数逐次 右移 然后和1 与,
//就得到最低位的情况,其他位都为0,
//如果最低位是0和1与 之后依旧 是0，如果是1，与之后还是1。
//对于32位的整数 这样移动32次 就记录了这个数二进制中1的个数了 
public static int NumberOf1_CanUse(int n) {
        int count = 0;
        for (int i = 0; i < Integer.toBinaryString(n).length(); i++) {
            if((n >> i & 1) == 1){
                count++;
            }
        }
        return count;
    }
```

```java
public int NumberOf1_low2(int n) {
    String str = null;
    int count = 0;
    if(n < 0){
        //负数的补码 = 负数的绝对值的原码 + 1
        str = Integer.toBinaryString(~(-n) + 1);
    } else{
        str = Integer.toBinaryString(n);
    }
    char[] arr = str.toCharArray();
    for(int i = 0 ; i<= str.length() - 1; i++){
        if(str.charAt(i) == '1'){
            count++;
        }
    }
    return count;
}
```





